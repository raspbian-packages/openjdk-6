diff -Nu old/AbstractImageProcessor.java PngReader/AbstractImageProcessor.java
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/javax/imageio/plugins/png/PngReader/AbstractImageProcessor.java	2011-06-21 11:46:22.000000000 +0200
@@ -0,0 +1,321 @@
+/*
+ * Copyright 2011 Red Hat, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+import java.awt.image.BufferedImage;
+import java.awt.image.RenderedImage;
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+import javax.imageio.IIOImage;
+import javax.imageio.ImageIO;
+import javax.imageio.ImageReader;
+import javax.imageio.stream.ImageInputStream;
+
+/**
+ * Abstract class containing only one visible method named run. This method
+ * tries to read all images from given directory and then check if no exception
+ * is thrown during image reading or if expected exception is really thrown.
+ * 
+ * This method also prints basic information for each image. Names of files
+ * containing images are based on schema proposed by Willem van Schaik, such
+ * files are included in PNGSUITE. For more information about the images
+ * please see file pngsuite.doc or look at page:
+ * http://www.schaik.com/pngsuite/pngsuite.html
+ * 
+ * @author Pavel Tisnovsky
+ */
+public class AbstractImageProcessor {
+
+    // maps used for decoding image attributes from file name
+    static final Map<String, String> testTypes = new HashMap<String, String>();
+    static final Map<String, String> colorTypes = new HashMap<String, String>();
+
+    static {
+        // Background tests
+        testTypes.put("bga", "alpha no");
+        testTypes.put("bgw", "alpha white");
+        testTypes.put("bgg", "alpha gray");
+        testTypes.put("bgb", "alpha black");
+        testTypes.put("bgy", "alpha yellow");
+
+        // Gamma tests
+        testTypes.put("g03", "0.35:2.8");
+        testTypes.put("g04", "0.45:2.2 (PC)");
+        testTypes.put("g05", "0.55:1.8 (Mac)");
+        testTypes.put("g07", "0.70:1.4");
+        testTypes.put("g10", "1.00:1.0 (NeXT)");
+        testTypes.put("g25", "2.50:0.4");
+
+        // Transparency tests
+        testTypes.put("tp0", "not transparent for reference");
+        testTypes.put("tp1", "transparent, but no background chunk");
+        testTypes.put("tbw", "transparent + white background");
+        testTypes.put("tbg", "transparent + gray background");
+        testTypes.put("tbb", "transparent + black background");
+        testTypes.put("tby", "transparent + yellow background");
+        testTypes.put("tbr", "transparent + red background");
+
+        // Filtering tests
+        testTypes.put("f00", "no");
+        testTypes.put("f01", "sub");
+        testTypes.put("f02", "up");
+        testTypes.put("f03", "average");
+        testTypes.put("f04", "paeth");
+
+        // Additional palette tests
+        testTypes.put("pp", "normal palette chunk");
+        testTypes.put("ps", "suggested palette chunk");
+
+        // Chunk ordering tests
+        testTypes.put("oi1", "mother image with 1 idat-chunk");
+        testTypes.put("oi2", "image with 2 idat-chunks");
+        testTypes.put("oi4", "image with 4 unequal sized idat-chunks");
+        testTypes.put("oi9", "all idat-chunks of length one");
+
+        // Auxiliary chunks tests
+        testTypes.put("cs3", "3 significant bits");
+        testTypes.put("cs5", "5 significant bits");
+        testTypes.put("cs8", "8 significant bits (reference)");
+        testTypes.put("cdf", "physical pixel dimensions, 8x32 flat pixels");
+        testTypes.put("cdh", "physical pixel dimensions, 32x8 high pixels");
+        testTypes.put("cds", "physical pixel dimensions, 8x8 square pixels");
+        testTypes.put("cdu", "physical pixel dimensions, with unit-specifier");
+        testTypes.put("ccw", "primary chromaticities and white point");
+        testTypes.put("ch1", "histogram 15 colors");
+        testTypes.put("ch2", "histogram 256 colors");
+        testTypes.put("cm7", "modification time, 01-jan-1970");
+        testTypes.put("cm9", "modification time, 31-dec-1999");
+        testTypes.put("cm0", "modification time, 01-jan-2000");
+        testTypes.put("ct0", "no textual data");
+        testTypes.put("ct1", "with textual data");
+        testTypes.put("ctz", "with compressed textual data");
+
+        // Corrupted images
+        testTypes.put("x00", "empty IDAT chunk");
+        testTypes.put("xcr", "added cr bytes");
+        testTypes.put("xlf", "added lf bytes");
+        testTypes.put("xc0", "color type 0");
+        testTypes.put("xc9", "color type 9");
+        testTypes.put("xd0", "bit-depth 0");
+        testTypes.put("xd3", "bit-depth 3");
+        testTypes.put("xd9", "bit-depth 99");
+        testTypes.put("xcs", "incorrect IDAT checksum");
+
+        // Color types
+        colorTypes.put("0g", "grayscale");
+        colorTypes.put("1g", "grayscale");
+        colorTypes.put("2c", "RGB color");
+        colorTypes.put("3p", "palette");
+        colorTypes.put("4a", "grayscale + alpha");
+        colorTypes.put("6a", "RGB color + alpha");
+    }
+
+    /**
+     * This method tries to read external file containing raster image using
+     * ImageReader. When the image file is corrupted or does not contains any
+     * data, exception is thrown.
+     *
+     * @param file path to image file
+     * @return RenderedImage extracted from given file
+     * @throws ImageReadException thrown in case image file is corrupted
+     */
+    protected RenderedImage readRenderedImage(File file) throws ImageReadException, Exception {
+        try {
+            ImageInputStream imageInputStream = ImageIO.createImageInputStream(file);
+            ImageReader imageReader = ImageIO.getImageReaders(imageInputStream).next();
+            imageReader.setInput(imageInputStream);
+            IIOImage image = imageReader.readAll(0, null);
+            return image.getRenderedImage();
+        }
+        catch (IOException e) {
+            //e.printStackTrace();
+            throw new ImageReadException(file.getName());
+        }
+    }
+
+    /**
+     * This method tries to read external file containing raster image using
+     * method ImageIO.read(). Because this method returns null if no registered
+     * ImageReader claims to be able to read the resulting stream, we need to
+     * cope with this.
+     * 
+     * @param file file path to image file
+     * @return BufferedImage extracted from given file
+     * @throws ImageReadException thrown in case image file is corrupted
+     */
+    protected BufferedImage readBufferedImage(File file) throws ImageReadException {
+        try {
+            BufferedImage bufferedImage = ImageIO.read(file);
+            // this is mandatory as we need to throw an exception when
+            // ImageIO.read() returns null!
+            if (bufferedImage == null) {
+                throw new ImageReadException(file.getName());
+            }
+            bufferedImage.toString();
+            return bufferedImage;
+        }
+        catch (IOException e) {
+            //e.printStackTrace();
+            throw new ImageReadException(file.getName());
+        }
+    }
+
+    /**
+     * This method extract various informations from name of image.
+     *
+     * @param fileName
+     * @return text containing basic info about image
+     */
+    protected String getImageInfoFromFileName(String fileName) {
+        String testType = resolveTestType(fileName.substring(0, 3));
+        String interlaced = resolveInterlaced(fileName.charAt(3));
+        String colorType = fileName.substring(4, 6);
+        String bitDepth = fileName.substring(6, 8);
+        colorType = resolveColorType(fileName.substring(4, 6));
+        return String.format("test type:   %s\ninterlace:   %s\ncolor type:  %s\ncolor depth: %s",
+                testType, interlaced, colorType, bitDepth);
+    }
+
+    private String resolveTestType(String str) {
+        if ("bas".equals(str)) {
+            return "basic test";
+        }
+        switch (str.charAt(0)) {
+        case 'b':
+            return namedTestType("background", str, "background");
+        case 'c':
+            return namedTestType("auxiliary chunks", str);
+        case 'f':
+            return namedTestType("filtering", str, "filtering");
+        case 'g':
+            return gammaTest(str);
+        case 'o':
+            return namedTestType("chunk ordering", str);
+        case 'p':
+            return namedTestType("additional palette", str.substring(0, 2));
+        case 's':
+            return sizeTest(str);
+        case 't':
+            return namedTestType("transparency", str);
+        case 'x':
+            return namedTestType("corrupted image", str);
+        case 'z':
+            return compressionLevelTest(str);
+        default:
+            return "unknown " + str;
+        }
+    }
+
+    @SuppressWarnings("boxing")
+    private String sizeTest(String str) {
+        int size = Integer.parseInt(str.substring(1, 3));
+        String suffix = size > 1 ? "s" : "";
+        return String.format("size test for image of size %dx%s pixel%s", size, size, suffix);
+    }
+
+    private String namedTestType(String name, String str) {
+        return namedTestType(name, str, "");
+    }
+
+    private String namedTestType(String name, String str, String suffix) {
+        if (testTypes.containsKey(str)) {
+            return name + " test: " + testTypes.get(str) + " " + suffix;
+        }
+        return "unknown " + name + " test: " + str;
+    }
+
+    private String compressionLevelTest(String str) {
+        return "zlib test for compression level " + str.charAt(2);
+    }
+
+    private String gammaTest(String str) {
+        if (testTypes.containsKey(str)) {
+            String[] vals = testTypes.get(str).split(":");
+            return "gamma test: file-gamma = " + vals[0] + ", for display with gamma = " + vals[1];
+        }
+        return "unknown gamma test: " + str;
+    }
+
+    private String resolveColorType(String str) {
+        if (colorTypes.containsKey(str)) {
+            return colorTypes.get(str);
+        }
+        return "unknown! " + str;
+    }
+
+    private String resolveInterlaced(char ch) {
+        return ch == 'i' ? "interlaced" : "non-interlaced";
+    }
+
+    protected String[] getSortedImageNames(File imageDir) {
+        String[] imageNames = imageDir.list();
+        Arrays.sort(imageNames);
+        return imageNames;
+    }
+
+    /**
+     * This method tries to read all images from given directory and then
+     * check if no exception is thrown (expectException==false) or if
+     * only expected exception is thrown (expectException==true).
+     *
+     * @param imageDirectoryName directory containing images
+     * @param expectException if IOException is expected to be thrown
+     *                        (ie the images are broken)
+     */
+    protected void run(String imageDirectoryName, boolean expectException) {
+        File imageDir = new File(System.getProperty("test.src", "."), imageDirectoryName);
+        String[] imageNames = getSortedImageNames(imageDir);
+        int errors = 0;
+        for (String imageName : imageNames) {
+            File imageFile = new File(imageDir, imageName);
+            System.out.println("\nChecking image: " + imageFile.getAbsolutePath());
+            System.out.println(getImageInfoFromFileName(imageName));
+            try {
+                readBufferedImage(imageFile);
+                readRenderedImage(imageFile);
+                if (expectException) {
+                    errors++;
+                    System.out.println("Exception not thrown as expected!");
+                }
+            }
+            catch (ImageReadException e) {
+                if (!expectException) {
+                    errors++;
+                    System.out.println("Exception thrown where not expected!");
+                }
+                else {
+                    System.out.println("Exception thrown as expected");
+                }
+            }
+            catch (Exception e) {
+                errors++;
+                System.out.println("Unexpected exception! ");
+                e.printStackTrace();
+            }
+        }
+        if (errors > 0) {
+            throw new RuntimeException("Error processing " + errors + " images");
+        }
+    }
+
+}
diff -Nu old/BrokenPngImageProcessor.java PngReader/BrokenPngImageProcessor.java
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/javax/imageio/plugins/png/PngReader/BrokenPngImageProcessor.java	2011-01-28 17:47:13.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2011 Red Hat, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+/**
+ * @test
+ * @summary This test checks if the ImageIO subsystem throws proper exception if
+ *          broken PNG image is to be read.
+ * 
+ * @author Pavel Tisnovsky
+ * 
+ */
+public class BrokenPngImageProcessor extends AbstractImageProcessor {
+    private static final String IMAGE_DIR = "broken_images";
+    private static final boolean EXPECT_EXCEPTION = true;
+
+    public static void main(String args[]) {
+        new BrokenPngImageProcessor().run(IMAGE_DIR, EXPECT_EXCEPTION);
+    }
+}
diff -Nu old/GoodPngImageProcessor.java PngReader/GoodPngImageProcessor.java
--- /dev/null	1970-01-01 01:00:00.000000000 +0100
+++ openjdk/jdk/test/javax/imageio/plugins/png/PngReader/GoodPngImageProcessor.java	2011-01-28 17:47:17.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2011 Red Hat, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+/**
+ * @test
+ * @summary This test check if the ImageIO subsystem is able to process various
+ *          types of PNG images which are known to have valid format.
+ * 
+ * @author Pavel Tisnovsky
+ * 
+ */
+public class GoodPngImageProcessor extends AbstractImageProcessor {
+    private static final String IMAGE_DIR = "good_images";
+    private static final boolean EXPECT_EXCEPTION = false;
+
+    public static void main(String args[]) {
+        new GoodPngImageProcessor().run(IMAGE_DIR, EXPECT_EXCEPTION);
+    }
+}
--- /dev/null	2011-03-28 09:47:44.855266162 +0200
+++ openjdk/jdk/test/javax/imageio/plugins/png/PngReader/ImageCompareException.java	2011-06-21 11:32:11.000000000 +0200
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2011 Red Hat, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+public class ImageCompareException extends Exception {
+    /**
+     * Generated serial version UID.
+     */
+    private static final long serialVersionUID = -8857533785949817059L;
+
+    private int x;
+    private int y;
+    private int r1;
+    private int g1;
+    private int b1;
+    private int r2;
+    private int g2;
+    private int b2;
+
+    public ImageCompareException(int x, int y, int r1, int g1, int b1, int r2, int g2, int b2) {
+        this.x = x;
+        this.y = y;
+        this.r1 = r1;
+        this.g1 = g1;
+        this.b1 = b1;
+        this.r2 = r2;
+        this.g2 = g2;
+        this.b2 = b2;
+    }
+
+    @SuppressWarnings({ "boxing", "unqualified-field-access" })
+    @Override
+    public String toString() {
+        return String.format("pixel [%d,%d] values differ: (%d, %d, %d) <> (%d, %d, %d)\n", x, y, r1, g1, b1, r2, g2, b2);
+    }
+}
--- /dev/null	2011-03-28 09:47:44.855266162 +0200
+++ openjdk/jdk/test/javax/imageio/plugins/png/PngReader/ImageReaderAndComparator.java	2011-06-21 11:48:38.123378000 +0200
@@ -0,0 +1,276 @@
+/*
+ * Copyright 2011 Red Hat, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+import java.awt.image.BufferedImage;
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+
+/**
+ * @test
+ * @summary This test check if the PNG images read by ImageIO system
+ *          has proper pixel values. Read images are checked against
+ *          corresponding PAM images generated by external tool.
+ *          This test are able to work with:
+ *          - grayscale images with 1 byte color depth (256 grayscales)
+ *          - grayscale images with 2 bytes color depth (65536 grayscales)
+ *          - RGB images with 1 byte color depth/color component (2^24 colors)
+ *          - RGB images with 2 bytes color depth/color component (2^48 colors)
+ * 
+ * @author Pavel Tisnovsky
+ * 
+ */
+public class ImageReaderAndComparator extends AbstractImageProcessor {
+
+    /**
+     * Directory containing tested PNG images.
+     */
+    private static final String PNG_IMAGE_DIR = "good_images";
+
+    /**
+     * Directory containing corresponding PAM images.
+     */
+    private static final String PAM_IMAGE_DIR = "pam_images";
+
+    /**
+     * Maximum allowable difference between color values of corresponding pixels.
+     */
+    private static int MAX_COLOR_COMPONENT_DIFF = 1;
+
+    /**
+     * Parse integer value from PAM file.
+     */
+    @SuppressWarnings("deprecation")
+    private int readIntegerFromPam(String attributeName, String fileName, DataInputStream input, int lineNumber)
+                    throws IOException, PamImageReadException {
+        String line;
+        line = input.readLine();
+        if (!line.startsWith(attributeName)) {
+            throw new PamImageReadException(fileName, lineNumber);
+        }
+        return Integer.parseInt(line.substring(line.indexOf(' ') + 1));
+    }
+
+    /**
+     * Linear to sRGB conversion
+     * @param Clinear color value in linear RGB color space
+     * @return color value in sRGB color space
+     */
+    private double linear2srgb(double Clinear)
+    {   
+        double alpha = 0.055;
+        return (Clinear <= 0.0031308) ? 12.92 * Clinear : (1. + alpha) * Math.pow(Clinear, 1 / 2.4) - alpha;
+    }
+
+    /**
+     * Read PAM image
+     * @param imageFile file containing image in PAM format
+     * @return raster image
+     * @throws IOException
+     * @throws PamImageReadException
+     */
+    @SuppressWarnings({ "deprecation", "boxing" })
+    private BufferedImage readPamImage(File imageFile) throws IOException, PamImageReadException {
+        // PAM image header format:
+        // P7
+        // WIDTH 32
+        // HEIGHT 32
+        // DEPTH 1
+        // MAXVAL 1
+        // ENDHDR
+        String fileName = imageFile.getName();
+        DataInputStream input = new DataInputStream(new BufferedInputStream(new FileInputStream(imageFile)));
+        int lineNumber = 1;
+        String line;
+
+        // check first line of PAM image
+        line = input.readLine();
+        if (! "P7".equals(line)) {
+            throw new PamImageReadException(fileName, lineNumber);
+        }
+
+        lineNumber++;
+        int width = readIntegerFromPam("WIDTH", fileName, input, lineNumber);
+        lineNumber++;
+        int height = readIntegerFromPam("HEIGHT", fileName, input, lineNumber);
+        lineNumber++;
+        int depth = readIntegerFromPam("DEPTH", fileName, input, lineNumber);
+        lineNumber++;
+        int maxval = readIntegerFromPam("MAXVAL", fileName, input, lineNumber);
+
+        input.readLine(); // ENDHDR
+        System.out.format("width: %d, height: %d, depth: %d, maxval: %d\n", width, height, depth, maxval); 
+
+        BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                int rgb;
+                switch (depth) {
+                    case 1:
+                        int grayLevel = readOneColorComponent(maxval, input, true);
+                        rgb = (grayLevel << 16) + (grayLevel << 8) + grayLevel;
+                        img.setRGB(x, y, rgb);
+                        break;
+                    case 4:
+                        int r = readOneColorComponent(maxval, input, false);
+                        int g = readOneColorComponent(maxval, input, false);
+                        int b = readOneColorComponent(maxval, input, false);
+                        // ignore alpha channel for the moment
+                        input.readUnsignedByte();
+                        if (maxval == 65535) {
+                            input.readUnsignedByte();
+                        }
+                        rgb = (r << 16) + (g << 8) + b;
+                        img.setRGB(x, y, rgb);
+                        break;
+                    default:
+                        throw new PamImageReadException("unknown color depth");
+                }
+            }
+        }
+        return img;
+    }
+
+    /**
+     * Read one color component from PAM file
+     * @param maxval
+     * @param input
+     * @param convertToSRGB 
+     * @return
+     * @throws IOException
+     */
+    private int readOneColorComponent(int maxval, DataInputStream input, boolean convertToSRGB) throws IOException {
+        int i = input.readUnsignedByte();
+        if (maxval == 65535) {
+            int i2 = input.readUnsignedByte();
+            double c = (double) ((i << 8) + i2) / maxval;
+            if (convertToSRGB) {
+                c = linear2srgb(c);
+            }
+            i = (int) (c * 255.0);
+        }
+        else if (maxval == 255) {
+            double c = (double) i / maxval;
+            if (convertToSRGB) {
+                c = linear2srgb(c);
+            }
+            i = (int) (c * 255.0);
+        }
+        else {
+            i = i * 255 / maxval;
+        }
+        return i;
+    }
+
+    /**
+     * Compare two images
+     * @param img1
+     * @param img2
+     * @throws Exception
+     */
+    private void compareImages(BufferedImage img1, BufferedImage img2) throws Exception {
+        if (img1 == null || img2 == null) {
+            throw new Exception("at least one image can not be read");
+        }
+        if (img1.getWidth() != img2.getWidth() || img1.getHeight() != img2.getHeight()) {
+            throw new Exception("image size differs");
+        }
+        System.out.println();
+        for (int y = 0; y < img1.getHeight(); y++) {
+            for (int x = 0; x < img1.getWidth(); x++) {
+                int rgb1 = img1.getRGB(x, y);
+                int rgb2 = img2.getRGB(x, y);
+
+                int r1 = rgb1 & 0xff;
+                int b1 = (rgb1 >> 8) & 0xff;
+                int g1 = (rgb1 >> 16) & 0xff;
+
+                int r2 = rgb2 & 0xff;
+                int b2 = (rgb2 >> 8) & 0xff;
+                int g2 = (rgb2 >> 16) & 0xff;
+
+                if (Math.abs(r1 - r2) > MAX_COLOR_COMPONENT_DIFF || Math.abs(g1 - g2) > MAX_COLOR_COMPONENT_DIFF  || Math.abs(b1 - b2) > MAX_COLOR_COMPONENT_DIFF   ) {
+                    throw new ImageCompareException(x, y, r1, g1, b1, r2, g2, b2);
+                }
+            }
+        }
+        System.out.println("OK - images are the same");
+    }
+
+    /**
+     * Run the test
+     */
+    private void run() {
+        File pngImageDir = new File(System.getProperty("test.src", "."), PNG_IMAGE_DIR);
+        File pamImageDir = new File(System.getProperty("test.src", "."), PAM_IMAGE_DIR);
+        String[] imageNames = getSortedImageNames(pngImageDir);
+        int errors = 0;
+        int comparingOk = 0;
+        int comparingErrors = 0;
+        for (String imageName : imageNames) {
+            File imageFile1 = new File(pngImageDir, imageName);
+            File imageFile2 = new File(pamImageDir, imageName.replace(".png", ".pam"));
+            System.out.println("\nChecking images: " + imageFile1.getAbsolutePath() + " and "
+                            + imageFile2.getAbsolutePath());
+            //System.out.println(getImageInfoFromFileName(imageName));
+            try {
+                BufferedImage img1 = readBufferedImage(imageFile1);
+                BufferedImage img2 = readPamImage(imageFile2);
+                try {
+                    compareImages(img1, img2);
+                    comparingOk++;
+                }
+                catch (ImageCompareException e) {
+                    comparingErrors++;
+                    e.printStackTrace();
+                }
+                catch (Exception e) {
+                    comparingErrors++;
+                    e.printStackTrace();
+                }
+            }
+            catch (ImageReadException e) {
+                errors++;
+                e.printStackTrace();
+            }
+            catch (IOException e) {
+                errors++;
+                e.printStackTrace();
+            }
+            catch (PamImageReadException e) {
+                errors++;
+                e.printStackTrace();
+            }
+        }
+        if (comparingErrors > 0) {
+            throw new RuntimeException("Catch " + comparingErrors + " comparison failures");
+        }
+        if (errors > 0) {
+            throw new RuntimeException("Error processing " + errors + " images");
+        }
+        System.out.format("Sucessfuly compared %d images!\n", Integer.valueOf(comparingOk));
+    }
+    
+    public static void main(String args[]) {
+        new ImageReaderAndComparator().run();
+    }
+    
+}
--- /dev/null	2011-03-28 09:47:44.855266162 +0200
+++ openjdk/jdk/test/javax/imageio/plugins/png/PngReader/ImageReadException.java	2011-01-28 17:47:22.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2011 Red Hat, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+
+public class ImageReadException extends Exception {
+
+    private String fileName;
+
+    /**
+     * Generated serial version UID
+     */
+    private static final long serialVersionUID = 4418111891788280159L;
+
+    public ImageReadException(String fileName) {
+        this.setFileName(fileName);
+    }
+
+    /**
+     * @param fileName the fileName to set
+     */
+    public void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+
+    /**
+     * @return the fileName
+     */
+    public String getFileName() {
+        return this.fileName;
+    }
+
+}
--- /dev/null	2011-03-28 09:47:44.855266162 +0200
+++ openjdk/jdk/test/javax/imageio/plugins/png/PngReader/PamImageReadException.java	2011-06-21 11:32:23.000000000 +0200
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2011 Red Hat, Inc. All Rights Reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+public class PamImageReadException extends Exception {
+
+    private String message = "";
+    private String fileName = "";
+    private int lineNumber = 0;
+
+    /**
+     * Generated serial version UID
+     */
+    private static final long serialVersionUID = -1324117718127778562L;
+
+    public PamImageReadException(String fileName, int lineNumber) {
+        this.setFileName(fileName);
+        this.setLineNumber(lineNumber);
+    }
+
+    public PamImageReadException(String message) {
+        this.setMessage(message);
+    }
+
+    private void setMessage(String message) {
+        this.message = message;
+    }
+
+    private void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+
+    private void setLineNumber(int lineNumber) {
+        this.lineNumber = lineNumber;
+    }
+
+    @Override
+    public String getMessage() {
+        return "Error reading file " + this.fileName + " on line " + this.lineNumber + "  message: " + this.message;
+    }
+
+}
--- /dev/null	2011-03-28 09:47:44.855266162 +0200
+++ openjdk/jdk/test/javax/imageio/plugins/png/PngReader/pngsuite.doc	1998-04-05 17:02:03.000000000 +0200
@@ -0,0 +1,520 @@
+        PNGSUITE
+----------------
+
+        testset for PNG-(de)coders
+        created by Willem van Schaik
+------------------------------------
+
+This is a collection of graphics images created to test the png applications
+like viewers, converters and editors. All (as far as that is possible)
+formats supported by the PNG standard are represented.
+
+
+1.      INTRODUCTION
+--------------------
+
+1.1     PNG capabilities
+------------------------
+
+Supported color-types are:
+
+        -   grayscale
+        -   grayscale + alpha-channel
+        -   color palettes
+        -   rgb
+        -   rgb + alpha-channel
+
+Allowed bitdepths are depending on the color-type, but are in the range
+of 1-bit (grayscale, which is b&w) upto 16-bits.
+
+Special features are:
+
+        -   interlacing (Adam-7)
+        -   gamma-support
+        -   transparency (a poor-man's alpha solution)
+
+
+1.2     File naming
+-------------------
+
+Where possible, the testfiles are 32x32 bits icons. This results in a still
+reasonable size of the suite even with a large number of tests. The name
+of each test-file reflects thetype in the following way:
+
+        g04i2c08.png
+        || |||+---- bit-depth
+        || ||+----- color-type (descriptive)
+        || |+------ color-type (numerical)
+        || +------- interlaced or non-interlaced
+        |+--------- parameter of test (in this case gamma-value)
+        +---------- test feature (in this case gamma)
+
+
+1.3     PNG formats
+-------------------
+
+color-type:
+        0g          -   grayscale
+        2c          -   rgb color
+        3p          -   paletted
+        4a          -   grayscale + alpha channel
+        6a          -   rgb color + alpha channel
+
+bit-depth:
+        01          -   with color-type 0, 3
+        02          -   with color-type 0, 3
+        04          -   with color-type 0, 3
+        08          -   with color-type 0, 2, 3, 4, 6
+        16          -   with color-type 0, 2, 4, 6
+
+interlacing:
+        n           -   non-interlaced
+        i           -   interlaced
+
+
+2.      THE TESTS
+-----------------
+
+2.1     Sizes
+-------------
+
+These tests are there to check if your software handles pictures well, with
+picture sizes that are not a multiple of 8. This is particularly important
+with Adam-7 type interlacing. In the same way these tests check if pictures
+size 1x1 and similar are ok.
+
+        s01         -   1x1 pixel picture
+        s02         -   2x2 pixel picture
+        s03         -   3x3 pixel picture
+        s04         -   4x4 pixel picture
+        s05         -   5x5 pixel picture
+        s06         -   6x6 pixel picture
+        s07         -   7x7 pixel picture
+        s08         -   8x8 pixel picture
+        s09         -   9x9 pixel picture
+        s32         -   32x32 pixel picture
+        s33         -   33x33 pixel picture
+        s34         -   34x34 pixel picture
+        s35         -   35x35 pixel picture
+        s36         -   36x36 pixel picture
+        s37         -   37x37 pixel picture
+        s38         -   38x38 pixel picture
+        s39         -   39x39 pixel picture
+        s40         -   40x40 pixel picture
+
+
+2.2     Background
+------------------
+
+When the PNG file contains a background chunck, this should be used for
+pictures with alpha-channel or pictures with a transparency chunck. For
+pictures without this background-chunk, but with alpha, this testset
+assumes a black background.
+
+For the images in this test, the left-side should be 100% the background
+color, where moving to the right the color should gradually become the
+image pattern.
+
+        bga         -   alpha + no background
+        bgw         -   alpha + white background
+        bgg         -   alpha + gray background
+        bgb         -   alpha + black background
+        bgy         -   alpha + yellow background
+
+
+2.3     Transparency
+--------------------
+
+Transparency should be used together with a background chunk. To test the
+combination of the two the latter 4 tests are there. How to handle pictures
+with transparancy, but without a background, opinions can differ. Here we
+use black, but especially in the case of paletted images, the normal color
+would maybe even be better.
+
+        tp0         -   not transparent for reference
+        tp1         -   transparent, but no background chunk
+        tbw         -   transparent + white background
+        tbg         -   transparent + gray background
+        tbb         -   transparent + black background
+        tby         -   transparent + yellow background
+
+
+2.4     Gamma
+-------------
+
+To test if your viewer handles gamma-correction, 6 testfiles are available.
+They contain corrected color-ramps and a corresponding gamma-chunk with the
+file-gamma value. These are created in such a way that when the viewer does
+the gamma correction right, all 6 should be displayed identical.
+
+If they are different, probably the gamma correction is omitted. In that
+case, have a look at the two right coloumns in the 6 pictures. The image
+where those two look the same (when looked from far) reflects the gamma of
+your system. However, because of the limited size of the image, you should
+do more elaborate tests to determine your display gamma.
+
+        g03         -   file-gamma = 0.35, for display with gamma = 2.8
+        g04         -   file-gamma = 0.45, for display with gamma = 2.2 (PC)
+        g05         -   file-gamma = 0.55, for display with gamma = 1.8 (Mac)
+        g07         -   file-gamma = 0.70, for display with gamma = 1.4
+        g10         -   file-gamma = 1.00, for display with gamma = 1.0 (NeXT)
+        g25         -   file-gamma = 2.50, for display with gamma = 0.4
+
+
+2.5     Filtering
+-----------------
+
+PNG uses file-filtering, for optimal compression. Normally the type is of
+filtering is adjusted to the contents of the picture, but here each file
+has the same picture, with a different filtering.
+
+        f0          -   no filtering
+        f1          -   sub filtering
+        f2          -   up filtering
+        f3          -   average filtering
+        f4          -   paeth filtering
+
+
+2.6     Additional palettes
+---------------------------
+
+Besides the normal use of paletted images, palette chunks can in combination
+with true-color (and other) images also be used to select color lookup-tables
+when the video system is of limited capabilities. The suggested palette chunk
+is specially created for this purpose.
+
+        pp          -   normal palette chunk
+        ps          -   suggested palette chunk
+
+
+2.7     Ancillary chunks (under construction)
+------------------------
+
+To test the correct decoding of ancillary chunks, these test-files contain
+one or more examples of these chunkcs. Depending on the type of chunk, a
+number of typical values are selected to test. Unluckily, the testset can
+not contain all combinations, because that would be an endless set.
+
+The significant bits are used in files with the next higher bit-depth. They
+indicate howmany bits are valid.
+
+        cs3         -   3 significant bits
+        cs5         -   5 significant bits
+        cs8         -   8 significant bits (reference)
+        cs3         -   13 significant bits
+
+For the physical pixel dimensions, the result of each decoding should be
+a sqare picture. The first (cdf) image is an example of flat (horizontal)
+pixels, where the pHYS chunk (x is 1 per unit, y = 4 per unit) must take
+care of the correction. The second is just the other way round. The last
+example uses the unit specifier, for 1000 pixels per meter. This should
+result in a picture of 3.2 cm square.
+
+        cdf         -   physical pixel dimensions, 8x32 flat pixels
+        cdh         -   physical pixel dimensions, 32x8 high pixels
+        cds         -   physical pixel dimensions, 8x8 square pixels
+        cdu         -   physical pixel dimensions, with unit-specifier
+
+        ccw         -   primary chromaticities and white point
+
+        ch1         -   histogram 15 colors
+        ch2         -   histogram 256 colors
+
+        cm7         -   modification time, 01-jan-1970
+        cm9         -   modification time, 31-dec-1999
+        cm0         -   modification time, 01-jan-2000
+
+In the textual chunk, a number of the standard, and some non-standard
+text items are included.
+
+        ct0         -   no textual data
+        ct1         -   with textual data
+        ctz         -   with compressed textual data
+
+
+2.8     Chunk ordering (still under construction)
+----------------------
+
+These testfiles will test the obligatory ordering relations between various
+chunk types (not yet) as well as the number of data chunks used for the image.
+
+        oi1         -   mother image with 1 idat-chunk
+        oi2         -   image with 2 idat-chunks
+        oi4         -   image with 4 unequal sized idat-chunks
+        oi9         -   all idat-chunks of length one
+
+
+2.9     Compression level
+-------------------------
+
+Here you will find a set of images compressed by zlib, ranging from level 0 
+for no compression at maximum speed upto level 9 for maximum compression.
+
+        z00         -   zlib compression level 0 - none
+        z03         -   zlib compression level 3
+        z06         -   zlib compression level 6 - default
+        z09         -   zlib compression level 9 - maximum
+
+
+2.10     Corrupted files (under construction)
+-----------------------
+
+All these files are illegal. When decoding they should generate appropriate
+error-messages.
+
+        x00         -   empty IDAT chunk
+        xcr         -   added cr bytes
+        xlf         -   added lf bytes
+        xc0         -   color type 0
+        xc9         -   color type 9
+        xd0         -   bit-depth 0
+        xd3         -   bit-depth 3
+        xd9         -   bit-depth 99
+        xcs         -   incorrect IDAT checksum
+
+
+3.      TEST FILES
+------------------
+
+For each of the tests listed above, one or more test-files are created. A
+selection is made (for each test) for the color-type and bitdepth to be used
+for the tests. Further for a number of tests, both a non-interlaced as well
+as an interlaced version is available.
+
+
+3.1     Basic format test files (non-interlaced)
+------------------------------------------------
+
+        basn0g01    -   black & white
+        basn0g02    -   2 bit (4 level) grayscale
+        basn0g04    -   4 bit (16 level) grayscale
+        basn0g08    -   8 bit (256 level) grayscale
+        basn0g16    -   16 bit (64k level) grayscale
+        basn2c08    -   3x8 bits rgb color
+        basn2c16    -   3x16 bits rgb color
+        basn3p01    -   1 bit (2 color) paletted
+        basn3p02    -   2 bit (4 color) paletted
+        basn3p04    -   4 bit (16 color) paletted
+        basn3p08    -   8 bit (256 color) paletted
+        basn4a08    -   8 bit grayscale + 8 bit alpha-channel
+        basn4a16    -   16 bit grayscale + 16 bit alpha-channel
+        basn6a08    -   3x8 bits rgb color + 8 bit alpha-channel
+        basn6a16    -   3x16 bits rgb color + 16 bit alpha-channel
+
+
+3.2     Basic format test files (Adam-7 interlaced)
+---------------------------------------------------
+
+        basi0g01    -   black & white
+        basi0g02    -   2 bit (4 level) grayscale
+        basi0g04    -   4 bit (16 level) grayscale
+        basi0g08    -   8 bit (256 level) grayscale
+        basi0g16    -   16 bit (64k level) grayscale
+        basi2c08    -   3x8 bits rgb color
+        basi2c16    -   3x16 bits rgb color
+        basi3p01    -   1 bit (2 color) paletted
+        basi3p02    -   2 bit (4 color) paletted
+        basi3p04    -   4 bit (16 color) paletted
+        basi3p08    -   8 bit (256 color) paletted
+        basi4a08    -   8 bit grayscale + 8 bit alpha-channel
+        basi4a16    -   16 bit grayscale + 16 bit alpha-channel
+        basi6a08    -   3x8 bits rgb color + 8 bit alpha-channel
+        basi6a16    -   3x16 bits rgb color + 16 bit alpha-channel
+
+
+3.3     Sizes test files
+-----------------------
+
+        s01n3p01    -   1x1 paletted file, no interlacing
+        s02n3p01    -   2x2 paletted file, no interlacing
+        s03n3p01    -   3x3 paletted file, no interlacing
+        s04n3p01    -   4x4 paletted file, no interlacing
+        s05n3p02    -   5x5 paletted file, no interlacing
+        s06n3p02    -   6x6 paletted file, no interlacing
+        s07n3p02    -   7x7 paletted file, no interlacing
+        s08n3p02    -   8x8 paletted file, no interlacing
+        s09n3p02    -   9x9 paletted file, no interlacing
+        s32n3p04    -   32x32 paletted file, no interlacing
+        s33n3p04    -   33x33 paletted file, no interlacing
+        s34n3p04    -   34x34 paletted file, no interlacing
+        s35n3p04    -   35x35 paletted file, no interlacing
+        s36n3p04    -   36x36 paletted file, no interlacing
+        s37n3p04    -   37x37 paletted file, no interlacing
+        s38n3p04    -   38x38 paletted file, no interlacing
+        s39n3p04    -   39x39 paletted file, no interlacing
+        s40n3p04    -   40x40 paletted file, no interlacing
+
+        s01i3p01    -   1x1 paletted file, interlaced
+        s02i3p01    -   2x2 paletted file, interlaced
+        s03i3p01    -   3x3 paletted file, interlaced
+        s04i3p01    -   4x4 paletted file, interlaced
+        s05i3p02    -   5x5 paletted file, interlaced
+        s06i3p02    -   6x6 paletted file, interlaced
+        s07i3p02    -   7x7 paletted file, interlaced
+        s08i3p02    -   8x8 paletted file, interlaced
+        s09i3p02    -   9x9 paletted file, interlaced
+        s32i3p04    -   32x32 paletted file, interlaced
+        s33i3p04    -   33x33 paletted file, interlaced
+        s34i3p04    -   34x34 paletted file, interlaced
+        s35i3p04    -   35x35 paletted file, interlaced
+        s36i3p04    -   36x36 paletted file, interlaced
+        s37i3p04    -   37x37 paletted file, interlaced
+        s38i3p04    -   38x38 paletted file, interlaced
+        s39i3p04    -   39x39 paletted file, interlaced
+        s40i3p04    -   40x40 paletted file, interlaced
+
+
+3.4     Background test files (with alpha)
+------------------------------------------
+
+        bgai4a08    -   8 bit grayscale, alpha, no background chunk, interlaced
+        bgai4a16    -   16 bit grayscale, alpha, no background chunk, interlaced
+        bgan6a08    -   3x8 bits rgb color, alpha, no background chunk
+        bgan6a16    -   3x16 bits rgb color, alpha, no background chunk
+
+        bgbn4a08    -   8 bit grayscale, alpha, black background chunk
+        bggn4a16    -   16 bit grayscale, alpha, gray background chunk
+        bgwn6a08    -   3x8 bits rgb color, alpha, white background chunk
+        bgyn6a16    -   3x16 bits rgb color, alpha, yellow background chunk
+
+
+3.5     Transparency (and background) test files
+------------------------------------------------
+
+        tp0n1g08    -   not transparent for reference (logo on gray)
+        tbbn1g04    -   transparent, black background chunk
+        tbwn1g16    -   transparent, white background chunk
+        tp0n2c08    -   not transparent for reference (logo on gray)
+        tbrn2c08    -   transparent, red background chunk
+        tbgn2c16    -   transparent, green background chunk
+        tbbn2c16    -   transparent, blue background chunk
+        tp0n3p08    -   not transparent for reference (logo on gray)
+        tp1n3p08    -   transparent, but no background chunk
+        tbbn3p08    -   transparent, black background chunk
+        tbgn3p08    -   transparent, light-gray background chunk
+        tbwn3p08    -   transparent, white background chunk
+        tbyn3p08    -   transparent, yellow background chunk
+
+
+3.6     Gamma test files
+------------------------
+
+        g03n0g16    -   grayscale, file-gamma = 0.35
+        g04n0g16    -   grayscale, file-gamma = 0.45
+        g05n0g16    -   grayscale, file-gamma = 0.55
+        g07n0g16    -   grayscale, file-gamma = 0.70
+        g10n0g16    -   grayscale, file-gamma = 1.00
+        g25n0g16    -   grayscale, file-gamma = 2.50
+        g03n2c08    -   color, file-gamma = 0.35
+        g04n2c08    -   color, file-gamma = 0.45
+        g05n2c08    -   color, file-gamma = 0.55
+        g07n2c08    -   color, file-gamma = 0.70
+        g10n2c08    -   color, file-gamma = 1.00
+        g25n2c08    -   color, file-gamma = 2.50
+        g03n3p04    -   paletted, file-gamma = 0.35
+        g04n3p04    -   paletted, file-gamma = 0.45
+        g05n3p04    -   paletted, file-gamma = 0.55
+        g07n3p04    -   paletted, file-gamma = 0.70
+        g10n3p04    -   paletted, file-gamma = 1.00
+        g25n3p04    -   paletted, file-gamma = 2.50
+
+
+3.7     Filtering test files
+----------------------------
+
+        f00n0g08    -   grayscale, no interlacing, filter-type 0
+        f01n0g08    -   grayscale, no interlacing, filter-type 1
+        f02n0g08    -   grayscale, no interlacing, filter-type 2
+        f03n0g08    -   grayscale, no interlacing, filter-type 3
+        f04n0g08    -   grayscale, no interlacing, filter-type 4
+        f00n2c08    -   color, no interlacing, filter-type 0
+        f01n2c08    -   color, no interlacing, filter-type 1
+        f02n2c08    -   color, no interlacing, filter-type 2
+        f03n2c08    -   color, no interlacing, filter-type 3
+        f04n2c08    -   color, no interlacing, filter-type 4
+
+
+3.8     Additional palette chunk test files
+-------------------------------------------
+
+        pp0n2c16    -   six-cube palette-chunk in true-color image
+        pp0n6a08    -   six-cube palette-chunk in true-color+alpha image
+        ps1n0g08    -   six-cube suggested palette (1 byte) in grayscale image
+        ps1n2c16    -   six-cube suggested palette (1 byte) in true-color image
+        ps2n0g08    -   six-cube suggested palette (2 bytes) in grayscale image
+        ps2n2c16    -   six-cube suggested palette (2 bytes) in true-color image
+
+
+3.9     Ancillary chunks test files
+-----------------------------------
+
+        cs5n2c08    -   color, 5 significant bits
+        cs8n2c08    -   color, 8 significant bits (reference)
+        cs3n2c16    -   color, 13 significant bits
+        cs3n3p08    -   paletted, 3 significant bits
+        cs5n3p08    -   paletted, 5 significant bits
+        cs8n3p08    -   paletted, 8 significant bits (reference)
+
+        cdfn2c08    -   physical pixel dimensions, 8x32 flat pixels
+        cdhn2c08    -   physical pixel dimensions, 32x8 high pixels
+        cdsn2c08    -   physical pixel dimensions, 8x8 square pixels
+        cdun2c08    -   physical pixel dimensions, 1000 pixels per 1 meter
+
+        ccwn2c08    -   chroma chunk w:0.3127,0.3290 r:0.64,0.33 g:0.30,0.60 b:0.15,0.06
+        ccwn3p08    -   chroma chunk w:0.3127,0.3290 r:0.64,0.33 g:0.30,0.60 b:0.15,0.06
+
+        ch1n3p04    -   histogram 15 colors
+        ch2n3p08    -   histogram 256 colors
+
+        cm7n0g04    -   modification time, 01-jan-1970 00:00:00
+        cm9n0g04    -   modification time, 31-dec-1999 23:59:59
+        cm0n0g04    -   modification time, 01-jan-2000 12:34:56
+
+        ct0n0g04    -   no textual data
+        ct1n0g04    -   with textual data
+        ctzn0g04    -   with compressed textual data
+
+
+
+3.10    Chunk ordering
+----------------------
+
+        oi1n0g16    -   grayscale mother image with 1 idat-chunk
+        oi2n0g16    -   grayscale image with 2 idat-chunks
+        oi4n0g16    -   grayscale image with 4 unequal sized idat-chunks
+        oi9n0g16    -   grayscale image with all idat-chunks length one
+        oi1n2c16    -   color mother image with 1 idat-chunk
+        oi2n2c16    -   color image with 2 idat-chunks
+        oi4n2c16    -   color image with 4 unequal sized idat-chunks
+        oi9n2c16    -   color image with all idat-chunks length one
+
+
+
+3.11    Compression level
+-------------------------
+
+        z00n2c08    -   color, no interlacing, compression level 0 (none)
+        z03n2c08    -   color, no interlacing, compression level 3
+        z06n2c08    -   color, no interlacing, compression level 6 (default)
+        z09n2c08    -   color, no interlacing, compression level 9 (maximum)
+
+
+
+3.12     Currupted files
+-----------------------
+
+        x00n0g01    -   empty 0x0 grayscale file
+        xcrn0g04    -   added cr bytes
+        xlfn0g04    -   added lf bytes
+        xc0n0c08    -   color type 0
+        xc9n0c08    -   color type 9
+        xd0n2c00    -   bit-depth 0
+        xd3n2c03    -   bit-depth 3
+        xd9n2c99    -   bit-depth 99
+        xcsn2c08    -   incorrect IDAT checksum
+
+
+--------
+    (c) Willem van Schaik
+        willem@schaik.com
+        Singapore, October 1996
